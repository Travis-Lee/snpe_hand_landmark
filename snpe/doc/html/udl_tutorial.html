<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2016-2018 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->
<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"></meta>
<meta http-equiv="X-UA-Compatible" content="IE=9"></meta>
<title>Snapdragon Neural Processing Engine SDK: User-Defined Layers (UDL) Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"></link>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="autoEnterCurrentDate.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="is.css" rel="stylesheet" type="text/css" ></link>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Snapdragon Neural Processing Engine SDK
   <span id="projectnumber"></span></div>
   <div id="projectbrief">Reference Guide</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('udl_tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User-Defined Layers (UDL) Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tutorial_udl_prerequisites"></a>
Prerequisites</h1>
<ul>
<li>
The SNPE SDK has been set up following the <a class="el" href="setup.html">SNPE Setup</a> chapter. </li>
<li>
The <a class="el" href="tutorial_setup.html">Tutorials Setup</a> has been completed. </li>
<li>
Caffe cloned and built from source. Follow the instructions at <a class="el" href="setup_caffe.html">Caffe &amp; Caffe2 Setup</a> to fetch and compile Caffe from source. </li>
</ul>
<h1><a class="anchor" id="tutorial_udl_introduction"></a>
Introduction</h1>
<p>This tutorial goes through the complete user-defined layer workflow from training a model with a newly-defined layer to implementing the custom layer with SNPE's UDL APIs.</p>
<p><b>Note:</b></p>
<p>SNPE currently only supports user-defined layers in Caffe.<br />
 <b>UDL is deprecated from snpe-1.35.0. Check out <a class="el" href="udo_overview.html">Overview of UDO</a> for a newer version of this feature.</b></p>
<h1><a class="anchor" id="udl_tutorial_workflow"></a>
UDL Workflow</h1>
<p>The following figure shows an overview of the modifications needed to support user-defined layers that are unknown to the SNPE runtime and converters.</p>
<p>There are two main pieces that need to be implemented to add support for user-defined layers:</p><ul>
<li>Extend the model converter to handle the weights and parameters for the layer</li>
<li>Implement the code needed to execute the layer with SNPE runtime</li>
</ul>
<p><a class="anchor" id="fig_udl_workflow"></a><p> <div style= text-align:left;><img src="images/udl_workflow.png" alt="UDL workflow" width="60%" height="60%"><br/><br/><b></b></div><br/> </p>
<h2><a class="anchor" id="udl_tutorial_caffe_buildlayer"></a>
Basing a UDL on the Scale Layer in Caffe</h2>
<p>For this tutorial, the existing Scale layer implementation in Caffe will be used as the basis. ScaleParameter prototxt will be re-used to carry the parameters for the custom layer.</p>
<ol>
<li>
<p class="startli">Create copies of the Scale layer code </p><pre class="fragment">cp $CAFFE_HOME/include/caffe/layers/scale_layer.hpp $CAFFE_HOME/include/caffe/layers/mycustomscale_layer.hpp
cp $CAFFE_HOME/src/caffe/layers/scale_layer.cpp $CAFFE_HOME/src/caffe/layers/mycustomscale_layer.cpp
cp $CAFFE_HOME/src/caffe/layers/scale_layer.cu $CAFFE_HOME/src/caffe/layers/mycustomscale_layer.cu
</pre> <p class="endli"></p>
</li>
<li>
<p class="startli">Edit $CAFFE_HOME/include/caffe/layers/<b>mycustomscale_layer.hpp</b> with the following modifications: </p><ul>
<li>
Rename the class ScaleLayer to MyCustomScaleLayer </li>
<li>
Rename the class constructor </li>
<li>
Edit the type() method to return "MyCustomScale" instead of "Scale" </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit $CAFFE_HOME/src/caffe/layers/<b>mycustomscale_layer.cpp</b> with the following modifications: </p><ul>
<li>
Change the #include directive to include mycustomscale_layer.hpp instead of scale_layer.hpp </li>
<li>
Change all the method definitions to be of class MyCustomScaleLayer instead of ScaleLayer </li>
<li>
Change the STUB_GPU and INSTANTIATE_CLASS macros to pass MyCustomScaleLayer instead of ScaleLayer </li>
<li>
Change the REGISTER_LAYER_CLASS macro to pass MyCustomScale instead of Scale </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit $CAFFE_HOME/src/caffe/layers/<b>mycustomscale_layer.cu</b> with the following modifications: </p><ul>
<li>
Change the #include directive to include mycustomscale_layer.hpp instead of scale_layer.hpp </li>
<li>
Change all the method definitions to be of class MyCustomScaleLayer instead of ScaleLayer </li>
<li>
Change the INSTANTIATE_LAYER_GPU_FUNCS macro to pass MyCustomScaleLayer instead of ScaleLayer </li>
</ul>
<p class="endli"></p>
</li>
<li>
Rebuild Caffe with the new layer: <pre class="fragment">cd $CAFFE_HOME
make all
make distribute
make pycaffe
</pre>  </li>
</ol>
<h2><a class="anchor" id="udl_tutorial_caffe_train"></a>
Training MNIST with Modified LeNet Model that Includes MyCustomScale Layer</h2>
<p>Next, add MyCustomScale to the MNIST LeNet model to incorporate the MyCustomScale layer and train it to generate a caffemodel file.</p>
<ol>
<li>
<p class="startli">Follow the LeNet on MNIST Caffe tutorial at <a href="http://caffe.berkeleyvision.org/gathered/examples/mnist.html">http://caffe.berkeleyvision.org/gathered/examples/mnist.html</a> to train the unmodified model. This is also required to fetch the MNIST training and testing datasets. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create copies of the LeNet model and training scripts </p><pre class="fragment">cd $CAFFE_HOME/examples/mnist
cp lenet.prototxt mycustomlenet.prototxt
cp lenet_train_test.prototxt mycustomlenet_train_test.prototxt
cp lenet_solver.prototxt mycustomlenet_solver.prototxt
cp train_lenet.sh train_mycustomlenet.sh
</pre> <p class="endli"></p>
</li>
<li>
<p class="startli">Edit <b>mycustomlenet.prototxt</b> with the following modifications: </p><ul>
<li>
Modify the batch dimension of data layer to 1. The modified definition should resemble: <pre class="fragment">layer {
  name: "data"
  type: "Input"
  top: "data"
  input_param { shape: { dim: 1 dim: 1 dim: 28 dim: 28 } }
}
</pre>  </li>
<li>
Insert MyCustomScale layer after relu1. The layer definition looks as follows: <pre class="fragment">layer {
  bottom: "ip1"
  top: "scale"
  name: "scale"
  type: "MyCustomScale"
  scale_param {
    bias_term: false
  }
}
</pre>  </li>
<li>
Modify the bottom parameter in the following ip2 layer from ip1 to scale. The modified definition should resemble: <pre class="fragment">layer {
  name: "ip2"
  type: "InnerProduct"
  bottom: "scale"
  top: "ip2"
...
</pre>  </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit <b>mycustomlenet_train_test.prototxt</b> with the following modifications: </p><ul>
<li>
Insert MyCustomScale layer after relu1. For the initialization of scale weights, use a filler of zero weights. This ensures that the final trained model is highly sensitive to the scale layer weights. The layer definition should look as follows: <pre class="fragment">layer {
  bottom: "ip1"
  top: "scale"
  name: "scale"
  type: "MyCustomScale"
  scale_param {
    bias_term: false
    filler: { value: 0 }
  }
}
</pre> Note that scale_param is re-used to carry MyCustomScale's parameters.  </li>
<li>
Modify the bottom parameter in the following ip2 layer from ip1 to scale. The modified definition should resemble: <pre class="fragment">layer {
  name: "ip2"
  type: "InnerProduct"
  bottom: "scale"
  top: "ip2"
...
</pre>  </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit <b>mycustomlenet_solver.prototxt</b> with the following modifications: </p><ul>
<li>
Modify the 'net' parameter to point to mycustomlenet_train_test.prototxt </li>
<li>
Modify the 'snapshot_prefix' parameter to be "examples/mnist/mycustomlenet" </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit <b>train_mycustomlenet.sh</b> to take in the mycustomlenet_solver.prototxt solver file. </p>
<p class="endli"></p>
</li>
<li>
Finally, train the modified model. <pre class="fragment">cd $CAFFE_HOME
./examples/mnist/train_mycustomlenet.sh
</pre> The training will generate the weights into mycustomlenet_iter_10000.caffemodel file. This in combination with mycustomlenet.prototxt model definition file will be used to generate the SNPE dlc model.  </li>
</ol>
<h1><a class="anchor" id="udl_tutorial_conversion"></a>
Model Conversion Tool Extension</h1>
<p>Caffe models are converted to DLC models using the snpe-caffe-to-dlc executable. Support for user-defined layers is added by passing the [&ndash;udl] parameter with the filename and factory function of your udl python module.</p>
<p>To convert the Caffe model generated earlier with the MyCustomScale layer, run the following command: <br />
 Note: Follow setup instructions for setting SNPE_ROOT with CAFFE before running the following.</p>
<pre class="fragment">export PYTHONPATH=$PYTHONPATH:$SNPE_ROOT/examples/Python/UdlExample
python snpe-caffe-to-dlc \
    --input_network $CAFFE_HOME/examples/mnist/mycustomlenet.prototxt \
    --caffe_bin $CAFFE_HOME/examples/mnist/mycustomlenet_iter_10000.caffemodel \
    ---udl my_udl_layers udl_factory_func
    --output_path mycustomlenet.dlc
</pre><p>View the model details with snpe-dlc-info.</p>
<pre class="fragment">snpe-dlc-info -i mycustomlenet.dlc
</pre><p>Note the details of the user-defined layer. </p><pre class="fragment">...
| 5  | ip1   | fc            | pool2     | ip1       | 1x500    | param count: 400k (92.9%)        |
|    |       |               |           |           |          | MACs: 400k (17.4%)               |
| 6  | relu1 | neuron        | ip1       | relu1.ip1 | 1x500    | a: 0                             |
|    |       |               |           |           |          | b: 0                             |
|    |       |               |           |           |          | min_clamp: 0                     |
|    |       |               |           |           |          | max_clamp: 0                     |
|    |       |               |           |           |          | func: relu                       |
| 7  | scale | user_defined  | relu1.ip1 | scale     | 1x500    | blob_size: 2017                  |
| 8  | ip2   | fc            | scale     | ip2       | 1x10     | param count: 5k (1.16%)          |
|    |       |               |           |           |          | MACs: 5k (0.218%)                |
| 9  | prob  | softmax       | ip2       | prob      | 1x10     |                                  |
</pre><h2><a class="anchor" id="udl_tutorial_udl_parameter"></a>
How --udl parameter works with snpe-caffe-to-dlc to support MyCustomLayer</h2>
<p>Examine $SNPE_ROOT/examples/Python/UdlExample/my_udl_layers.py: </p><ol>
<li>
<p class="startli">udl_factory_func: the &ndash;udl parameters expects users to pass Filename, Function name. </p><ul>
<li>
Filename: Name of python module to load for registering custom udl(note: must be in PYTHONPATH). If file is part of a package, list the package.filename as you would when doing a python import.  </li>
<li>
Function name: Name of the udl factory function that returns a dictionary with layer_type as key and an object of UDL class as value. After instantiating the converter, this is used to set the UDL mapping from layer types to their handlers.  </li>
</ul>
<p>For our example, the Filename is my_udl_layers and Function name is udl_factory_func. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The UDL handler map (udl_supported_types) is a dictionary where the key is the layer name and the value is the handler class for that layer. </p><div class="fragment"><div class="line"><span class="comment"># UDL layer name to UDL  class map</span></div><div class="line">udl_supported_types = {</div><div class="line">    <span class="stringliteral">&#39;MyCustomScale&#39;</span>: udl_mycustomscale</div><div class="line">}</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">The UDL handler instance (udl_mycustomscale) needs a callback function and the expected input/output axes order of your custom layer implementation. </p><div class="fragment"><div class="line"><span class="comment"># Instance of Udl class for mycustomscale layer</span></div><div class="line">udl_mycustomscale = snpe_udl_utils.Udl(layer_callback=udl_mycustomscale_func,</div><div class="line">expected_axes_orders=[<span class="comment"># First supported input/output axes order (4D: NSC input, NSC output)</span></div><div class="line">                    (  <span class="comment"># input dims</span></div><div class="line">                     [AxisTracker.AxisAnnotations.BATCH, AxisTracker.AxisAnnotations.HEIGHT,</div><div class="line">                      AxisTracker.AxisAnnotations.WIDTH, AxisTracker.AxisAnnotations.CHANNEL],</div><div class="line">                     <span class="comment"># output dims</span></div><div class="line">                     [AxisTracker.AxisAnnotations.BATCH, AxisTracker.AxisAnnotations.HEIGHT,</div><div class="line">                      AxisTracker.AxisAnnotations.WIDTH, AxisTracker.AxisAnnotations.CHANNEL]</div><div class="line">                    ),</div><div class="line">                    <span class="comment"># Second supported input/output axes order (3D: NS input, NS output)</span></div><div class="line">                    (  <span class="comment"># input dims</span></div><div class="line">                     [AxisTracker.AxisAnnotations.BATCH, AxisTracker.AxisAnnotations.HEIGHT,</div><div class="line">                      AxisTracker.AxisAnnotations.WIDTH],</div><div class="line">                     <span class="comment"># output dims</span></div><div class="line">                     [AxisTracker.AxisAnnotations.BATCH, AxisTracker.AxisAnnotations.HEIGHT,</div><div class="line">                      AxisTracker.AxisAnnotations.WIDTH]</div><div class="line">                    ),</div><div class="line">                    <span class="comment"># Third supported input/output axes order (2D: NF input, NF output)</span></div><div class="line">                    (  <span class="comment"># input_dims</span></div><div class="line">                     [AxisTracker.AxisAnnotations.BATCH, AxisTracker.AxisAnnotations.FEATURE],</div><div class="line">                     <span class="comment"># output_dims</span></div><div class="line">                     [AxisTracker.AxisAnnotations.BATCH, AxisTracker.AxisAnnotations.FEATURE]</div><div class="line">                    )</div><div class="line">                   ]))</div></div><!-- fragment --> <p class="endli"></p>
</li>
<li>
<div class="fragment"><div class="line"><span class="comment"># Conversion callback function for MyCustomerLayer</span></div><div class="line"><span class="keyword">def </span>udl_mycustomscale_func(layer, input_dims):</div><div class="line">    blob = UdlBlobMyCustomScale(layer)</div><div class="line">    <span class="keywordflow">return</span> snpe_udl_utils.UdlBlobOutput(blob=blob, out_dims=input_dims)</div></div><!-- fragment --><p> The handler callback function for a custom layer receives the following parameters: </p><ul>
<li>
<b>layer</b>: The prototxt definition of the Caffe layer (does not include weights and biases) </li>
<li>
<b>input_dims</b>: Dimensions of the inputs to the custom layer </li>
</ul>
<p>The handler function returns: </p><ul>
<li>
<b>blob</b>: A wrapper object that wraps all the layer weights and params in a single packed buffer </li>
<li>
<b>out_dims</b>: Dimensions of the outputs of the custom layer </li>
</ul>
<p>For MyCustomScale layer, the output dimensions are the same as the input dimensions. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The UdlBlobMyCustomScale is a helper class used by udl_mycustomscale_func to generate a packed buffer that contains all the layer params and weights. UdlBlobMyCustomScale delegates the packing to another sub-class. </p><div class="fragment"><div class="line"><span class="comment"># UdlBlobMyCustomScale.__init__()</span></div><div class="line">snpe_params = UdlBlobMyCustomScale..MyCustomScaleLayerParam()</div></div><!-- fragment --><p> The remaining of UdlBlobMyCustomScale class's init method fills out the fields that need to be packed. For MyCustomScale, the only layer parameter is bias_term. Note that the handler function did not receive any layer weights, they come from the converter through weight_provider. The blob2arr() utility method provided by SNPE converts the Caffe blob to a linear array of floats. </p><div class="fragment"><div class="line">caffe_weights = snpeUtils.blob2arr(weight_provider.weights_map[layer.name][0])</div></div><!-- fragment --><p> Finally, call serialize() to generate the packed data. </p><div class="fragment"><div class="line">self._blob = snpe_params.serialize()</div><div class="line">self._size = len(self._blob)</div></div><!-- fragment --> <p class="endli"></p>
</li>
<li>
The MyCustomScaleLayerParam class, defined as subclass inside in UdlBlobMyCustomScale, packs all the layer data into a single buffer. This class defines the format by which the native code must load the layer data in the serialize() method. <div class="fragment"><div class="line"><span class="comment"># MyCustomScaleLayerParam.serialize()</span></div><div class="line">packed = struct.pack(<span class="stringliteral">&#39;i&#39;</span>, self.type)</div></div><!-- fragment --> First integer indicates the layer type. <div class="fragment"><div class="line">packed += struct.pack(<span class="stringliteral">&#39;?&#39;</span>, self.bias_term)</div></div><!-- fragment --> Next the parameter bias_term is a boolean type. <div class="fragment"><div class="line">packed += struct.pack(<span class="stringliteral">&#39;I%sI&#39;</span> % len(self.weights_dim),</div><div class="line">                      len(self.weights_dim), *self.weights_dim)</div></div><!-- fragment --> Next the array containing the dimensions of the weights. This is done by first packing an integer marking the number of elements in the array followed by the array values, which are also integers. <div class="fragment"><div class="line">packed += struct.pack(<span class="stringliteral">&#39;I%sf&#39;</span> % len(self.weights_data),</div><div class="line">                      len(self.weights_data), *self.weights_data)</div></div><!-- fragment --> Finally the array containing the weight values. This is done by first packing an integer marking the number of elements in the array followed by the array values, which are floats.  </li>
</ol>
<h1><a class="anchor" id="udl_tutorial_implementation"></a>
Changes for SNPE Runtime</h1>
<p>This section outlines the code changes necessary to implement a user-defined layer called by SNPE runtime.</p>
<p>A native example that implements the MyCustomScale layer is located at $SNPE_ROOT/examples/NativeCpp/UdlExample. This example extends the native BatchRun utility to support MyCustomScale layer via SNPE's UDL APIs.</p>
<p><b>jni/main.cpp</b>:</p>
<div class="fragment"><div class="line"><span class="comment">// Specify UDL bundle prior to creating a SNPE object</span></div><div class="line"><a class="code" href="group__c__plus__plus__apis.html#structzdl_1_1DlSystem_1_1UDLBundle">zdl::DlSystem::UDLBundle</a> udlBundle;</div><div class="line">udlBundle.cookie = (<span class="keywordtype">void</span>*)0xdeadbeaf;</div><div class="line">udlBundle.func = udlexample::MyUDLFactory;</div><div class="line">zdl::DlSystem::RuntimeList runtimeList;</div><div class="line">runtimeList.add(<a class="code" href="group__c__plus__plus__apis.html#gga45e3c64e55f150f9cc11028200b79911a802a23be4084111f01e3c1e0b3294bcb">zdl::DlSystem::Runtime_t::CPU_FLOAT32</a>);</div><div class="line">...</div><div class="line">snpe = snpeBuilder.setOutputLayers({})</div><div class="line">                  .setRuntimeProcessorOrder(runtimeList)</div><div class="line">                  .setUdlBundle(udlBundle)</div><div class="line">                  .setDebugMode(DebugNetworkOutputs)</div><div class="line">                  .build();</div></div><!-- fragment --><p> The setUdlBundle() method in SNPEBuilder is passed a UDLBundle object. This bundle object contains two fields: </p><ul>
<li>
<b>cookie</b>: Pointer to an opaque data type. This pointer is returned to the user during layer construction and execution.  </li>
<li>
<b>func</b>: User-implemented factory method to handle the construction of user-defined layers.  </li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Function signature of the UDL Factory function</span></div><div class="line"><a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1IUDL">zdl::DlSystem::IUDL</a>* MyUDLFactory(<span class="keywordtype">void</span>* cookie, <span class="keyword">const</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UDLContext">zdl::DlSystem::UDLContext</a>* c)</div></div><!-- fragment --><p> The UDL factory method receives the opaque data passed in earlier (cookie) and a UDLContext object. The UDLContext object contains all the available information about the custom layer.</p>
<div class="fragment"><div class="line"><span class="comment">// MyUDLFactory()</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>* blob = c-&gt;<a class="code" href="group__c__plus__plus__apis.html#a0c041579f1a7b3851219f43c723b7dbf">getBlob</a>();</div><div class="line"><span class="keywordtype">size_t</span> size = c-&gt;<a class="code" href="group__c__plus__plus__apis.html#affcefe7263555102e5d6d24db180b9e0">getSize</a>();</div><div class="line">myudl::CommonLayerParams params;</div><div class="line"><span class="keywordflow">if</span>(!myudl::ParseCommonLayerParams(blob, size, params)) {</div><div class="line">    PrintErrorStringAndExit(<span class="stringliteral">&quot;Failed to parse common layer params&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p> The UDL factory method parses the layer data to retrieve the layer type. Once the layer type is known the method instantiates and returns a pointer to the layer object.</p>
<p>The function for parsing the layer type from the packed layer data is defined in MyUdlLayers.hpp. It reads the first integer from the buffer, which denotes the layer type.</p>
<div class="fragment"><div class="line"><span class="comment">// MyUDLFactory()</span></div><div class="line"><span class="keywordflow">switch</span>(params.type) {</div><div class="line">    <span class="keywordflow">case</span> myudl::MY_CUSTOM_SCALE_LAYER:</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> myudl::UdlMyCustomScale(*c);</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        PrintErrorStringAndExit(<span class="stringliteral">&quot;Unknown layer type&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>Finally the factory method instantiates the requested layer.</p>
<p><b>udlMyCustomScaleLayer.hpp</b></p>
<p>A UDL implementation must extend the interface <a class="el" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1IUDL">zdl::DlSystem::IUDL</a>. This interface defined the following methods that need to be implemented by the user: </p><ul>
<li>
Setup: Gives the layer an opportunity to setup any internal state. </li>
<li>
Close: The layer should release any handles and deallocate any resources. </li>
<li>
Execute: A single forward pass of the layer. The layer should compute the outputs given the inputs. </li>
</ul>
<p>Further, in this example a private method ParseMyCustomLayerParams() is used to handle the parsing of the packed data from the DLC model.</p>
<p><b>udlMyCustomScaleLayer.cpp</b></p>
<p>The UdlMyCustomScale::ParseMyCustomLayerParams() method handles the parsing of the packed layer data to initialize the parameters and weights for MyCustomScale layer. The unpacking is performed in the same order as the packing in MyUdlLayers.py.</p>
<p>The <b>UdlMyCustomScale::Setup()</b> method performs layer initialization. It receives the following parameters: </p><ul>
<li>
<b>size_t insz</b>: Number of inputs </li>
<li>
<b>const size_t* indim[]</b>: Dimensions for each of the inputs. There are insz number of pointers, where each points to an array containing the input dimensions for the corresponding input </li>
<li>
<b>const size_t indimsz[]</b>: The size of each array in indim[] </li>
<li>
<b>size_t outsz</b>: Number of outputs </li>
<li>
<b>const size_t* outdim[]</b>: Dimensions for each of the outputs. There are outsz number of pointers, where each points to an array containing the output dimensions for the corresponding output </li>
<li>
<b>const size_t outdimsz[]</b>: The size of each array in outdim[] </li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (insz != 1 or outsz != 1) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p> It first checks the number of inputs and outputs. In this example a single-input single-output scale layer is implemented.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> inszdim = getSizeByDim(</div><div class="line">        std::vector&lt;size_t&gt;(indim[0], indim[0] + indimsz[0]));</div><div class="line">m_OutSzDim = getSizeByDim(</div><div class="line">        std::vector&lt;size_t&gt;(outdim[0], outdim[0] + outdimsz[0]));</div><div class="line"><span class="keywordflow">if</span> (inszdim != m_OutSzDim) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p> Next it verifies that the total size of input matches the total size of the output as the Scale operation is one-to-one.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!ParseMyCustomLayerParams(blob, m_Context.getSize(), m_Params)) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p> Then it calls the ParseMyCustomLayerParams() method to read the packed layer data and initialize the custom layer.</p>
<p>Finally, the method verifies that bias_term is set to false since this example only implements the multiplicative scale operation.</p>
<p>The <b>UdlMyCustomScale::Execute()</b> method implements the forward pass for the custom layer.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; m_OutSzDim; i++) {</div><div class="line">    output[0][i] = input[0][i] * m_Params.weights_data[i];</div><div class="line">}</div></div><!-- fragment --><p> It scales each input value by the corresponding weight.</p>
<h1><a class="anchor" id="udl_tutorial_execution"></a>
Executing the Model</h1>
<p>With all the runtime pieces in place, BatchRun can be built with support for MyCustomScale user-defined layer.</p>
<p>First move to UDL example base directory.</p>
<pre class="fragment">cd $SNPE_ROOT/examples/NativeCpp/UdlExample
</pre><p>Run the following command to compile for x86 Linux targets.</p>
<pre class="fragment">make -f Makefile.x86_64-linux-clang
</pre><p>To build with clang/libc++ SNPE binaries (i.e., arm-android-clang6.0 and aarch64-android-clang6.0), use the following command:</p>
<pre class="fragment">ndk-build NDK_TOOLCHAIN_VERSION=clang APP_STL=c++_shared
</pre><p>The UDL-enabled BatchRun can be run on a Linux Host with the UDL model generated earlier. Sample inputs of hand-written characters are provided in $SNPE_ROOT/models/mnist/data. </p><pre class="fragment">cd $SNPE_ROOT/models/mnist/data
$SNPE_ROOT/examples/NativeCpp/UdlExample/obj/local/x86_64-linux-clang/snpe-net-run-udl \
  --container $SNPE_ROOT/examples/Python/UdlExample/mycustomlenet.dlc \
  --input_list image_list.txt
</pre><p>The MyCustomScale layer's Setup() method should output information about the layer parameters and weights: </p><pre class="fragment">UdlMyCustomScale::Setup() of name scale
UdlMyCustomScale::Setup() input size dim: 500, output: 500
UdlMyCustomScale::Setup() got blob size 2017
UdlMyCustomScale::Setup() bias_term=0
UdlMyCustomScale::Setup() weight dimensions: (500,)
UdlMyCustomScale::Setup() # weights=500
...
</pre><p>The outputs can be verified with the following script: </p><pre class="fragment">python3 ../scripts/interpretRawLeNetOutput.py output/Result_0/prob.raw
python3 ../scripts/interpretRawLeNetOutput.py output/Result_1/prob.raw
python3 ../scripts/interpretRawLeNetOutput.py output/Result_2/prob.raw
python3 ../scripts/interpretRawLeNetOutput.py output/Result_3/prob.raw
</pre><p>The classification results should be 0, 3, 5 and 9, respectively. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2016-2018 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 -->
<!-- start footer part -->
<div id="nav-path" class="navpath" font-size:small;><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <p align="right">
        80-NL315-14 A <br>
        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
        <!--If the Controlled Distribution statement is to be included, uncomment below:-->
        <!--<b>Controlled Distribution - DO NOT COPY</b>-->
        <img class="footer" width:5%; alt="QTI Logo" src="images/QTI_Logo.png" />
      </p>
    </li>
  </ul>
</div>
</body>
</html>
