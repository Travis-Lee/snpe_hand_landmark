<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2016-2018 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->
<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"></meta>
<meta http-equiv="X-UA-Compatible" content="IE=9"></meta>
<title>Snapdragon Neural Processing Engine SDK: C++ Tutorial - Build the Sample</title>
<link href="tabs.css" rel="stylesheet" type="text/css"></link>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="autoEnterCurrentDate.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="is.css" rel="stylesheet" type="text/css" ></link>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Snapdragon Neural Processing Engine SDK
   <span id="projectnumber"></span></div>
   <div id="projectbrief">Reference Guide</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('cplus_plus_tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C++ Tutorial - Build the Sample </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tutorial_cpp_prerequisites"></a>
Prerequisites</h1>
<ul>
<li>
The SNPE SDK has been set up following the <a class="el" href="setup.html">SNPE Setup</a> chapter. </li>
<li>
The <a class="el" href="tutorial_setup.html">Tutorials Setup</a> has been completed. </li>
</ul>
<h1><a class="anchor" id="tutorial_cpp_introduction"></a>
Introduction</h1>
<p>This tutorial demonstrates how to build a C++ sample application that can execute neural network models on the PC or target device.</p>
<p><b>Note:</b> While this sample code does not do any error checking, it is strongly recommended that users check for errors when using the SNPE APIs.</p>
<p>Most applications will follow the following pattern while using a neural network:</p>
<ol>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_runtime_check">Get Available Runtime</a> </li>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_load_container">Load Network</a> </li>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_set_container_builder">Set Network Builder Options</a> </li>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_load_network_inputs">Load Network Inputs</a> <ol>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_load_input_itensors">Using ITensors</a> </li>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_load_input_user_buffers">Using User Buffers</a> </li>
</ol>
</li>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_execute">Execute the Network &amp; Process Output</a> <ol>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_execute_itensors">Using ITensors</a> </li>
<li>
<a class="el" href="cplus_plus_tutorial.html#cpp_tutorial_execute_user_buffers">Using User Buffers</a> </li>
</ol>
</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="group__c__plus__plus__apis.html#ga45e3c64e55f150f9cc11028200b79911">zdl::DlSystem::Runtime_t</a> runtime = checkRuntime();</div><div class="line"></div><div class="line">std::unique_ptr&lt;zdl::DlContainer::IDlContainer&gt; container = loadContainerFromFile(dlc);</div><div class="line"></div><div class="line">std::unique_ptr&lt;zdl::SNPE::SNPE&gt; snpe = setBuilderOptions(container, runtime, udlBundle, useUserSuppliedBuffers);</div><div class="line"></div><div class="line">std::unique_ptr&lt;zdl::DlSystem::ITensor&gt; inputTensor = loadInputTensor(snpe, fileLine); <span class="comment">// ITensor</span></div><div class="line">loadInputUserBuffer(applicationInputBuffers, snpe, fileLine); <span class="comment">// User Buffer</span></div><div class="line"></div><div class="line">executeNetwork (snpe , inputTensor, OutputDir, inputListNum); <span class="comment">// ITensor</span></div><div class="line">executeNetwork(snpe, inputMap, outputMap, applicationOutputBuffers, OutputDir, inputListNum); <span class="comment">// User Buffer</span></div></div><!-- fragment --><p>The sections below describe how to implement each step described above. For more details, please refer to the collection of source code files located at $SNPE_ROOT/examples/NativeCpp/SampleCode/jni.</p>
<h1><a class="anchor" id="cpp_tutorial_runtime_check"></a>
Get Available Runtime</h1>
<p>The code excerpt below illustrates how to check if a specific runtime is available using the native APIs (the GPU runtime is used as an example).</p>
<div class="fragment"><div class="line"><a class="code" href="group__c__plus__plus__apis.html#ga45e3c64e55f150f9cc11028200b79911">zdl::DlSystem::Runtime_t</a> checkRuntime()</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1Version__t">zdl::DlSystem::Version_t</a> Version = <a class="code" href="group__c__plus__plus__apis.html#a1bea75ec1b66fa2f702c7c08f5cebca4">zdl::SNPE::SNPEFactory::getLibraryVersion</a>();</div><div class="line">    <span class="keyword">static</span> <a class="code" href="group__c__plus__plus__apis.html#ga45e3c64e55f150f9cc11028200b79911">zdl::DlSystem::Runtime_t</a> Runtime;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;SNPE Version: &quot;</span> &lt;&lt; Version.<a class="code" href="group__c__plus__plus__apis.html#gadd51fc6e317453f54301e900d2ea5b9b">asString</a>().c_str() &lt;&lt; std::endl; <span class="comment">//Print Version number</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__c__plus__plus__apis.html#a97e184dc199c74a7423b341f7aae9bf2">zdl::SNPE::SNPEFactory::isRuntimeAvailable</a>(<a class="code" href="group__c__plus__plus__apis.html#gga45e3c64e55f150f9cc11028200b79911a52f9ec21735243ad9917cda3ca077d32">zdl::DlSystem::Runtime_t::GPU</a>)) {</div><div class="line">        Runtime = <a class="code" href="group__c__plus__plus__apis.html#gga45e3c64e55f150f9cc11028200b79911a52f9ec21735243ad9917cda3ca077d32">zdl::DlSystem::Runtime_t::GPU</a>;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        Runtime = <a class="code" href="group__c__plus__plus__apis.html#gga45e3c64e55f150f9cc11028200b79911a2b55387dd066c5bac646ac61543d152d">zdl::DlSystem::Runtime_t::CPU</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> Runtime;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="cpp_tutorial_load_container"></a>
Load Network</h1>
<p>The code excerpt below illustrates how to load a network from the SNPE container file (DLC).</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;zdl::DlContainer::IDlContainer&gt; loadContainerFromFile(std::string containerPath)</div><div class="line">{</div><div class="line">    std::unique_ptr&lt;zdl::DlContainer::IDlContainer&gt; container;</div><div class="line">    container = <a class="code" href="group__c__plus__plus__apis.html#ga478a3589e407da28c4f4f09484064c8a">zdl::DlContainer::IDlContainer::open</a>(containerPath);</div><div class="line">    <span class="keywordflow">return</span> container;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="cpp_tutorial_set_container_builder"></a>
Set Network Builder Options</h1>
<p>The following code demonstrates how to instantiate a SNPE Builder object, which will be used to execute the network with the given parameters. </p><div class="fragment"><div class="line">std::unique_ptr&lt;zdl::SNPE::SNPE&gt; setBuilderOptions(std::unique_ptr&lt;zdl::DlContainer::IDlContainer&gt;&amp; container,</div><div class="line">                                                   zdl::DlSystem::RuntimeList runtimeList,</div><div class="line">                                                   <a class="code" href="group__c__plus__plus__apis.html#structzdl_1_1DlSystem_1_1UDLBundle">zdl::DlSystem::UDLBundle</a> udlBundle,</div><div class="line">                                                   <span class="keywordtype">bool</span> useUserSuppliedBuffers)</div><div class="line">{</div><div class="line">    std::unique_ptr&lt;zdl::SNPE::SNPE&gt; snpe;</div><div class="line">    <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1SNPE_1_1SNPEBuilder">zdl::SNPE::SNPEBuilder</a> snpeBuilder(container.get());</div><div class="line">    snpe = snpeBuilder.<a class="code" href="group__c__plus__plus__apis.html#a5aa93979416b17df898cb0c6f8425461">setOutputLayers</a>({})</div><div class="line">       .setRuntimeProcessorOrder(runtimeList)</div><div class="line">       .<a class="code" href="group__c__plus__plus__apis.html#ae663964a04959f3621786273396fbd1f">setUdlBundle</a>(udlBundle)</div><div class="line">       .<a class="code" href="group__c__plus__plus__apis.html#afba92f2fe2ba81cd36f285e7ad418c79">setUseUserSuppliedBuffers</a>(useUserSuppliedBuffers)</div><div class="line">       .<a class="code" href="group__c__plus__plus__apis.html#a179350ec9187a642813bb1e04bed7370">build</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> snpe;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="cpp_tutorial_load_network_inputs"></a>
Load Network Inputs</h1>
<p>Network inputs and outputs can be either user-backed buffers or ITensors (built-in SNPE buffers), but not both. The advantage of using user-backed buffers is that it eliminates an extra copy from user buffers to create ITensors. Both methods of loading network inputs are shown below.</p>
<h2><a class="anchor" id="cpp_tutorial_load_input_user_buffers"></a>
Using User Buffers</h2>
<p>SNPE can create its network inputs and outputs from user-backed buffers. Note that SNPE expects the values of the buffers to be present and valid during the duration of its execution.</p>
<p>Here is a function for creating a SNPE UserBuffer from a user-backed buffer and storing it in a <a class="el" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UserBufferMap">zdl::DlSystem::UserBufferMap</a>. These maps are a convenient collection of all input or output user buffers that can be passed to SNPE to execute the network.</p>
<p>Disclaimer: The strides of the buffer should already be known by the user and should not be calculated as shown below. The calculation shown is solely used for executing the example code.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> createUserBuffer(<a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UserBufferMap">zdl::DlSystem::UserBufferMap</a>&amp; userBufferMap,</div><div class="line">                      std::unordered_map&lt;std::string, std::vector&lt;uint8_t&gt;&gt;&amp; applicationBuffers,</div><div class="line">                      std::vector&lt;std::unique_ptr&lt;zdl::DlSystem::IUserBuffer&gt;&gt;&amp; snpeUserBackedBuffers,</div><div class="line">                      std::unique_ptr&lt;zdl::SNPE::SNPE&gt;&amp; snpe,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">char</span> * name)</div><div class="line">{</div><div class="line">   <span class="comment">// get attributes of buffer by name</span></div><div class="line">   <span class="keyword">auto</span> bufferAttributesOpt = snpe-&gt;getInputOutputBufferAttributes(name);</div><div class="line">   <span class="keywordflow">if</span> (!bufferAttributesOpt) <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;Error obtaining attributes for input tensor &quot;</span>) + name);</div><div class="line"></div><div class="line">   <span class="comment">// calculate the size of buffer required by the input tensor</span></div><div class="line">   <span class="keyword">const</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1TensorShape">zdl::DlSystem::TensorShape</a>&amp; bufferShape = (*bufferAttributesOpt)-&gt;getDims();</div><div class="line"></div><div class="line">   <span class="comment">// Calculate the stride based on buffer strides, assuming tightly packed.</span></div><div class="line">   <span class="comment">// Note: Strides = Number of bytes to advance to the next element in each dimension.</span></div><div class="line">   <span class="comment">// For example, if a float tensor of dimension 2x4x3 is tightly packed in a buffer of 96 bytes, then the strides would be (48,12,4)</span></div><div class="line">   <span class="comment">// Note: Buffer stride is usually known and does not need to be calculated.</span></div><div class="line">   std::vector&lt;size_t&gt; strides(bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga0733c94f87784147f398499c1bd7c713">rank</a>());</div><div class="line">   strides[strides.size() - 1] = <span class="keyword">sizeof</span>(float);</div><div class="line">   <span class="keywordtype">size_t</span> stride = strides[strides.size() - 1];</div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga0733c94f87784147f398499c1bd7c713">rank</a>() - 1; i &gt; 0; i--)</div><div class="line">   {</div><div class="line">      stride *= bufferShape[i];</div><div class="line">      strides[i-1] = stride;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">size_t</span> bufferElementSize = (*bufferAttributesOpt)-&gt;getElementSize();</div><div class="line">   <span class="keywordtype">size_t</span> bufSize = calcSizeFromDims(bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga352b3640f2e99867c092a1b260203a13">getDimensions</a>(), bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga0733c94f87784147f398499c1bd7c713">rank</a>(), bufferElementSize);</div><div class="line"></div><div class="line">   <span class="comment">// set the buffer encoding type</span></div><div class="line">   <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UserBufferEncodingFloat">zdl::DlSystem::UserBufferEncodingFloat</a> userBufferEncodingFloat;</div><div class="line"></div><div class="line">   <span class="comment">// create user-backed storage to load input data onto it</span></div><div class="line">   applicationBuffers.emplace(name, std::vector&lt;uint8_t&gt;(bufSize));</div><div class="line"></div><div class="line">   <span class="comment">// create SNPE user buffer from the user-backed buffer</span></div><div class="line">   <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1IUserBufferFactory">zdl::DlSystem::IUserBufferFactory</a>&amp; ubFactory = <a class="code" href="group__c__plus__plus__apis.html#ab32e0a7ce9242415177a00510f0978f1">zdl::SNPE::SNPEFactory::getUserBufferFactory</a>();</div><div class="line">   snpeUserBackedBuffers.push_back(ubFactory.<a class="code" href="group__c__plus__plus__apis.html#a58980a08c317c8dcb7943821e60f9cb8">createUserBuffer</a>(applicationBuffers.at(name).data(),</div><div class="line">                                                              bufSize,</div><div class="line">                                                              strides,</div><div class="line">                                                              &amp;userBufferEncodingFloat));</div><div class="line"></div><div class="line">   <span class="comment">// add the user-backed buffer to the inputMap, which is later on fed to the network for execution</span></div><div class="line">   userBufferMap.<a class="code" href="group__c__plus__plus__apis.html#a3deb982f909567eed3b86bead18a222e">add</a>(name, snpeUserBackedBuffers.back().get());</div><div class="line">}</div></div><!-- fragment --> <p>The following function then shows how to load input data from file(s) to user buffers. Note that the input values are simply loaded onto user-backed buffers, on top of which SNPE can create SNPE UserBuffers, as shown above.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> loadInputUserBuffer(std::unordered_map&lt;std::string, std::vector&lt;uint8_t&gt;&gt;&amp; applicationBuffers,</div><div class="line">                               std::unique_ptr&lt;zdl::SNPE::SNPE&gt;&amp; snpe,</div><div class="line">                               <span class="keyword">const</span> std::string&amp; fileLine)</div><div class="line">{</div><div class="line">    <span class="comment">// get input tensor names of the network that need to be populated</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; inputNamesOpt = snpe-&gt;getInputTensorNames();</div><div class="line">    <span class="keywordflow">if</span> (!inputNamesOpt) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Error obtaining input tensor names&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1StringList">zdl::DlSystem::StringList</a>&amp; inputNames = *inputNamesOpt;</div><div class="line">    assert(inputNames.<a class="code" href="group__c__plus__plus__apis.html#ga3caedb145a667c26028740417dcf32c3">size</a>() &gt; 0);</div><div class="line"></div><div class="line">    <span class="comment">// treat each line as a space-separated list of input files</span></div><div class="line">    std::vector&lt;std::string&gt; filePaths;</div><div class="line">    split(filePaths, fileLine, <span class="charliteral">&#39; &#39;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (inputNames.<a class="code" href="group__c__plus__plus__apis.html#ga3caedb145a667c26028740417dcf32c3">size</a>()) std::cout &lt;&lt; <span class="stringliteral">&quot;Processing DNN Input: &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; inputNames.<a class="code" href="group__c__plus__plus__apis.html#ga3caedb145a667c26028740417dcf32c3">size</a>(); i++) {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* name = inputNames.<a class="code" href="group__c__plus__plus__apis.html#ga7b4d8ef89ee330dc0c0b53937090fa68">at</a>(i);</div><div class="line">        std::string filePath(filePaths[i]);</div><div class="line"></div><div class="line">        <span class="comment">// print out which file is being processed</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;) &quot;</span> &lt;&lt; filePath &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// load file content onto application storage buffer,</span></div><div class="line">        <span class="comment">// on top of which, SNPE has created a user buffer</span></div><div class="line">        loadByteDataFile(filePath, applicationBuffers.at(name));</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="cpp_tutorial_load_input_itensors"></a>
Using ITensors</h2>
<div class="fragment"><div class="line">std::unique_ptr&lt;zdl::DlSystem::ITensor&gt; loadInputTensor (std::unique_ptr&lt;zdl::SNPE::SNPE&gt; &amp; snpe , std::string&amp; fileLine)</div><div class="line">{</div><div class="line">    std::unique_ptr&lt;zdl::DlSystem::ITensor&gt; input;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;strList_opt = snpe-&gt;getInputTensorNames();</div><div class="line">    <span class="keywordflow">if</span> (!strList_opt) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Error obtaining Input tensor names&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;strList = *strList_opt;</div><div class="line">    <span class="comment">// Make sure the network requires only a single input</span></div><div class="line">    assert (strList.size() == 1);</div><div class="line">    <span class="comment">// If the network has a single input, each line represents the input file to be loaded for that input</span></div><div class="line"></div><div class="line">    std::string filePath(fileLine);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Processing DNN Input: &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    std::vector&lt;float&gt; inputVec = loadFloatDataFile(filePath);</div><div class="line"></div><div class="line">    <span class="comment">/* Create an input tensor that is correctly sized to hold the input of the network. Dimensions that have no fixed size will be represented with a value of 0. */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;inputDims_opt = snpe-&gt;getInputDimensions(strList.at(0));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;inputShape = *inputDims_opt;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate the total number of elements that can be stored in the tensor so that we can check that the input contains the expected number of elements.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">       With the input dimensions computed create a tensor to convey the input into the network. */</span></div><div class="line">    input = <a class="code" href="group__c__plus__plus__apis.html#ac417494e4ca73c889e4617614ebe138a">zdl::SNPE::SNPEFactory::getTensorFactory</a>().<a class="code" href="group__c__plus__plus__apis.html#gac9bedc2da15c9c9552419aa9c2bb9c93">createTensor</a>(inputShape);</div><div class="line"></div><div class="line">    <span class="comment">/* Copy the loaded input file contents into the networks input tensor.SNPE&#39;s ITensor supports C++ STL functions like std::copy() */</span></div><div class="line"></div><div class="line">    std::copy(inputVec.begin(), inputVec.end(), input-&gt;begin());</div><div class="line">    <span class="keywordflow">return</span> input;</div><div class="line">}</div></div><!-- fragment -->  <h1><a class="anchor" id="cpp_tutorial_execute"></a>
Execute the Network &amp; Process Output</h1>
<p>The following snippets of code use the native API to execute the network (in UserBuffer or ITensor mode) and show how to iterate through the newly populated output tensor.</p>
<h2><a class="anchor" id="cpp_tutorial_execute_user_buffers"></a>
Using User Buffers</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> executeNetwork(std::unique_ptr&lt;zdl::SNPE::SNPE&gt;&amp; snpe,</div><div class="line">                    <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UserBufferMap">zdl::DlSystem::UserBufferMap</a>&amp; inputMap,</div><div class="line">                    <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UserBufferMap">zdl::DlSystem::UserBufferMap</a>&amp; outputMap,</div><div class="line">                    std::unordered_map&lt;std::string,std::vector&lt;uint8_t&gt;&gt;&amp; applicationOutputBuffers,</div><div class="line">                    <span class="keyword">const</span> std::string&amp; outputDir,</div><div class="line">                    <span class="keywordtype">int</span> num)</div><div class="line">{</div><div class="line">    <span class="comment">// Execute the network and store the outputs in user buffers specified in outputMap</span></div><div class="line">    snpe-&gt;execute(inputMap, outputMap);</div><div class="line"></div><div class="line">    <span class="comment">// Get all output buffer names from the network</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1StringList">zdl::DlSystem::StringList</a>&amp; outputBufferNames = outputMap.<a class="code" href="group__c__plus__plus__apis.html#a8c408d389a6127dcbb9c293a8eaf659c">getUserBufferNames</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Iterate through output buffers and print each output to a raw file</span></div><div class="line">    std::for_each(outputBufferNames.<a class="code" href="group__c__plus__plus__apis.html#ga38802824fae12d3836076a1baeb34edf">begin</a>(), outputBufferNames.<a class="code" href="group__c__plus__plus__apis.html#gadf5f2de7b732799845f583b2efcc5570">end</a>(), [&amp;](<span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div><div class="line">    {</div><div class="line">       std::ostringstream path;</div><div class="line">       path &lt;&lt; outputDir &lt;&lt; <span class="stringliteral">&quot;/Result_&quot;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;.raw&quot;</span>;</div><div class="line"></div><div class="line">       SaveUserBuffer(path.str(), applicationOutputBuffers.at(name));</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// The following is a partial snippet of the function</span></div><div class="line"><span class="keywordtype">void</span> SaveUserBuffer(<span class="keyword">const</span> std::string&amp; path, <span class="keyword">const</span> std::vector&lt;uint8_t&gt;&amp; buffer) {</div><div class="line">   ...</div><div class="line">   std::ofstream os(path, std::ofstream::binary);</div><div class="line">   <span class="keywordflow">if</span> (!os)</div><div class="line">   {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open output file for writing: &quot;</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      std::exit(EXIT_FAILURE);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (!os.write((<span class="keywordtype">char</span>*)(buffer.data()), buffer.size()))</div><div class="line">   {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to write data to: &quot;</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      std::exit(EXIT_FAILURE);</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="cpp_tutorial_execute_itensors"></a>
Using ITensors</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> executeNetwork(std::unique_ptr&lt;zdl::SNPE::SNPE&gt;&amp; snpe,</div><div class="line">                    std::unique_ptr&lt;zdl::DlSystem::ITensor&gt;&amp; input,</div><div class="line">                    std::string OutputDir,</div><div class="line">                    <span class="keywordtype">int</span> num)</div><div class="line">{</div><div class="line">    <span class="comment">//Execute the network and store the outputs that were specified when creating the network in a TensorMap</span></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1TensorMap">zdl::DlSystem::TensorMap</a> outputTensorMap;</div><div class="line">    snpe-&gt;execute(input.get(), outputTensorMap);</div><div class="line">    <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1StringList">zdl::DlSystem::StringList</a> tensorNames = outputTensorMap.<a class="code" href="group__c__plus__plus__apis.html#gabc1d6535ceb95c91dce681af915b051c">getTensorNames</a>();</div><div class="line"></div><div class="line">    <span class="comment">//Iterate through the output Tensor map, and print each output layer name</span></div><div class="line">    std::for_each( tensorNames.<a class="code" href="group__c__plus__plus__apis.html#ga38802824fae12d3836076a1baeb34edf">begin</a>(), tensorNames.<a class="code" href="group__c__plus__plus__apis.html#gadf5f2de7b732799845f583b2efcc5570">end</a>(), [&amp;](<span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div><div class="line">    {</div><div class="line">        std::ostringstream path;</div><div class="line">        path &lt;&lt; OutputDir &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Result_&quot;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">        &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;.raw&quot;</span>;</div><div class="line">        <span class="keyword">auto</span> tensorPtr = outputTensorMap.<a class="code" href="group__c__plus__plus__apis.html#gaf38cf0501efe3998ff8b427c2a8d791d">getTensor</a>(name);</div><div class="line">        SaveITensor(path.str(), tensorPtr);</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// The following is a partial snippet of the function</span></div><div class="line"><span class="keywordtype">void</span> SaveITensor(<span class="keyword">const</span> std::string&amp; path, <span class="keyword">const</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1ITensor">zdl::DlSystem::ITensor</a>* tensor)</div><div class="line">{</div><div class="line">   ...</div><div class="line"></div><div class="line">   std::ofstream os(path, std::ofstream::binary);</div><div class="line">   <span class="keywordflow">if</span> (!os)</div><div class="line">   {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open output file for writing: &quot;</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      std::exit(EXIT_FAILURE);</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> ( <span class="keyword">auto</span> it = tensor-&gt;<a class="code" href="group__c__plus__plus__apis.html#gaec868a117314fede39bbfee40802105b">cbegin</a>(); it != tensor-&gt;<a class="code" href="group__c__plus__plus__apis.html#ga9bfcd4d6da464cbb50302087529679ca">cend</a>(); ++it )</div><div class="line">   {</div><div class="line">      <span class="keywordtype">float</span> f = *it;</div><div class="line">      <span class="keywordflow">if</span> (!os.write(reinterpret_cast&lt;char*&gt;(&amp;f), <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)))</div><div class="line">      {</div><div class="line">         std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to write data to: &quot;</span> &lt;&lt; path &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">         std::exit(EXIT_FAILURE);</div><div class="line">      }</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment -->  <h1><a class="anchor" id="building_the_native_application"></a>
Building the C++ Application</h1>
<h2><a class="anchor" id="building_and_running_on_x86_linux"></a>
Building and Running on x86 Linux and Embedded Linux</h2>
<p>Start by going to the snpe-sample base directory.</p>
<pre class="fragment">cd $SNPE_ROOT/examples/NativeCpp/SampleCode
</pre><p>Note the different makefiles associated with the different Linux platform. Note that the $CXX would need to be set according to the target platform. Here is a table of the supported targets, and their corresponding settings for $CXX and the Makefiles to use.</p>
<p> <p><table class="doxtable" width="100%">  <tr>  <th colspan="1">Target</th> <th colspan="1">Makefile</th> <th colspan="1">Possible CXX value</th> <th colspan="1">Output Location</th>  </tr>  <tr> <td> aarch64-linux (gcc 4.9) </td>  <td> Makefile.aarch64-linux-gcc4.9 </td>  <td> aarch64-linux-gnu-g++ </td>  <td> aarch64-linux-gcc4.9 </td> </tr>  <tr> <td> arm-linux (gcc 4.9sf) </td>  <td> Makefile.arm-linux-gcc4.9sf </td>  <td> arm-linux-gnueabi-g++ </td>  <td> arm-linux-gcc4.9sf </td> </tr>  <tr> <td> arm-oe-linux (gcc 6.4hf) </td>  <td> Makefile.arm-oe-linux-gcc6.4hf </td>  <td> arm-oe-linux-g++ </td>  <td> arm-oe-linux-gcc6.4hf </td> </tr>  <tr> <td> aarch64-oe-linux (gcc 6.4) </td>  <td> Makefile.aarch64-oe-linux-gcc6.4 </td>  <td> aarch64-oe-linux-g++ </td>  <td> aarch64-oe-linux-gcc6.4 </td> </tr>  <tr> <td> x86_64-linux </td>  <td> Makefile.x86_64-linux-clang </td>  <td> g++ </td>  <td> x86_64-linux-clang </td> </tr>  </table></p><pre class="fragment">export CXX=&lt;Name of c++ cross compiler&gt;
make -f &lt;Makefile for the target&gt;
</pre><p><b>Note:</b> Ensure that the path to the compiler binary is already set in $PATH.</p>
<p>Along with the sample executable, all other libraries need to be pushed onto their respective targets. The $LD_LIBRARY_PATH may also need to be updated to point to the support libraries. You can run the executable with -h argument to see its description.</p>
<pre class="fragment">snpe-sample -h
</pre><p>The description should look like the following:</p>
<pre class="fragment">DESCRIPTION:
------------
Example application demonstrating how to load and execute a neural network
using the SNPE C++ API.


REQUIRED ARGUMENTS:
-------------------
  -d  &lt;FILE&gt;   Path to the DL container containing the network.
  -i  &lt;FILE&gt;   Path to a file listing the inputs for the network.
  -o  &lt;PATH&gt;   Path to directory to store output results.

OPTIONAL ARGUMENTS:
-------------------
  -b  &lt;TYPE&gt;   Type of buffers to use [USERBUFFER, ITENSOR] (default is USERBUFFER).
</pre><p>Running the snpe-sample assumes one of the examples <a class="el" href="tutorial_alexnet.html">Running the AlexNet Model</a> or <a class="el" href="tutorial_inceptionv3.html">Running the Inception v3 Model</a> has been previously setup.</p>
<p>Run <b>snpe-sample</b> with the AlexNet model:</p>
<pre class="fragment">cd $SNPE_ROOT/models/alexnet/data
$SNPE_ROOT/examples/NativeCpp/SampleCode/obj/local/x86_64-linux-clang/snpe-sample -b ITENSOR -d ../dlc/bvlc_alexnet.dlc -i target_raw_list.txt -o output
</pre><p>The results are stored in the output directory. To process the output run the following script to generate the classifiscation results.</p>
<pre class="fragment">python $SNPE_ROOT/models/alexnet/scripts/show_alexnet_classifications.py -i target_raw_list.txt -o output/ -l ilsvrc_2012_labels.txt
Classification results
cropped/trash_bin.raw     0.949348 412 ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin
cropped/chairs.raw        0.365685 831 studio couch, day bed
cropped/plastic_cup.raw   0.749103 647 measuring cup
cropped/notice_sign.raw   0.722709 458 brass, memorial tablet, plaque
cropped/handicap_sign.raw 0.188248 919 street sign
</pre><h2><a class="anchor" id="building_and_running_on_arm_android"></a>
Building and Running on ARM Android</h2>
<p><b>Prerequisite:</b> You will need the Android NDK to build the Android C++ executable. The tutorial assumes that you can invoke 'ndk-build' from the shell.</p>
<p>First move to snpe-sample's base directory.</p>
<pre class="fragment">cd $SNPE_ROOT/examples/NativeCpp/SampleCode
</pre><p>To build snpe-sample with clang/libc++ SNPE binaries (i.e., arm-android-clang6.0 and aarch64-android-clang6.0), use the following command:</p>
<pre class="fragment">cd $SNPE_ROOT/examples/NativeCpp/SampleCode
ndk-build NDK_TOOLCHAIN_VERSION=clang APP_STL=c++_shared
</pre><p>The ndk-build command will build both armeabi-v7a and arm64-v8a binaries of snpe-sample.</p>
<ul>
<li>
$SNPE_ROOT/examples/NativeCpp/SampleCode/obj/local/armeabi-v7a/<b>snpe-sample</b> </li>
<li>
$SNPE_ROOT/examples/NativeCpp/SampleCode/obj/local/arm64-v8a/<b>snpe-sample</b> </li>
</ul>
<p>To run the Android C++ executable, push the appropriate SNPE libraries and the executable onto the Android target.</p>
<pre class="fragment">export SNPE_TARGET_ARCH=arm-android-clang6.0
export SNPE_TARGET_ARCH_OBJ_DIR=armeabi-v7a
adb shell "mkdir -p /data/local/tmp/snpeexample/$SNPE_TARGET_ARCH/bin"
adb shell "mkdir -p /data/local/tmp/snpeexample/$SNPE_TARGET_ARCH/lib"
adb shell "mkdir -p /data/local/tmp/snpeexample/dsp/lib"
adb push $SNPE_ROOT/lib/$SNPE_TARGET_ARCH/ /data/local/tmp/snpeexample/$SNPE_TARGET_ARCH/lib
adb push $SNPE_ROOT/lib/dsp/ /data/local/tmp/snpeexample/dsp/lib
adb push $SNPE_ROOT/examples/NativeCpp/SampleCode/obj/local/$SNPE_TARGET_ARCH_OBJ_DIR/snpe-sample /data/local/tmp/snpeexample/$SNPE_TARGET_ARCH/bin
</pre><p>Run <b>snpe-sample</b> with the Alexnet model on the target. This assumes that you have done the setup steps for running <a class="el" href="tutorial_alexnet.html#tutorial_alexnet_run_on_android">Run on Android Target</a> to push to the target all the sample data files and Alexnet model.</p>
<pre class="fragment">adb shell
export SNPE_TARGET_ARCH=arm-android-clang6.0
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/data/local/tmp/snpeexample/$SNPE_TARGET_ARCH/lib
export PATH=$PATH:/data/local/tmp/snpeexample/$SNPE_TARGET_ARCH/bin
cd /data/local/tmp/alexnet
snpe-sample -b ITENSOR -d bvlc_alexnet.dlc -i target_raw_list.txt -o output_sample
exit
</pre><p>Pull the target output into a host side output directory.</p>
<pre class="fragment">cd $SNPE_ROOT/models/alexnet/
adb pull /data/local/tmp/alexnet/output_sample output_sample
</pre><p>Again, we can run the interpret script to see the classification results.</p>
<pre class="fragment">python $SNPE_ROOT/models/alexnet/scripts/show_alexnet_classifications.py -i data/target_raw_list.txt -o output_sample/ -l data/ilsvrc_2012_labels.txt
Classification results
cropped/trash_bin.raw     0.949348 412 ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin
cropped/chairs.raw        0.365685 831 studio couch, day bed
cropped/plastic_cup.raw   0.749103 647 measuring cup
cropped/notice_sign.raw   0.722709 458 brass, memorial tablet, plaque
cropped/handicap_sign.raw 0.188248 919 street sign
</pre><p>Similar example results can also be used using the Inception v3 model from <a class="el" href="tutorial_inceptionv3.html">Running the Inception v3 Model</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2016-2018 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 -->
<!-- start footer part -->
<div id="nav-path" class="navpath" font-size:small;><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <p align="right">
        80-NL315-14 A <br>
        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
        <!--If the Controlled Distribution statement is to be included, uncomment below:-->
        <!--<b>Controlled Distribution - DO NOT COPY</b>-->
        <img class="footer" width:5%; alt="QTI Logo" src="images/QTI_Logo.png" />
      </p>
    </li>
  </ul>
</div>
</body>
</html>
